use RBS::Types::Bases::Bottom

module Linguadata
  VERSION: String

  module DataHelpers
    class ZeroItemData < Data
      def self.new: () -> instance

      def self.[]: () -> instance

      def deconstruct: () -> [ ]

      def deconstruct_keys: (?Array[Symbol]?) -> { }
    end

    class OneItemData[T] < Data
      def self.new: [T] (T) -> instance

      def self.[]: [T] (T) -> instance

      def deconstruct: () -> [T]

      def deconstruct_keys: (?Array[Symbol]?) -> { Symbol: T }
    end
  end

  module Option
    type option[T] = (Some[T] | None) & _Option[T]

    class Some[T] < DataHelpers::OneItemData[T]
      include _Option[T]
    end

    class None < DataHelpers::ZeroItemData
      include _Option[Bottom]
    end

    interface _Option[T]
      def value: () -> T

      def unwrap: () -> T

      def some?: () -> bool

      def none?: () -> bool

      def map: [U] { (T) -> U } -> option[U]

      def unwrap_or: (T) -> T

      def unwrap_or_else: { () -> T } -> T
    end

    def from_nillable: [T] (T? value) -> option[T]
  end

  module Result
    type result[T, E] = (Success[T] | Failure[E]) & _Result[T, E]

    class Success[T] < DataHelpers::OneItemData[T]
      include _Result[T, Bottom]
    end

    class Failure[E] < DataHelpers::OneItemData[E]
      include _Result[Bottom, E]
    end

    interface _Result[T, E]
      def value: () -> T

      def error: () -> E

      def unwrap: () -> T

      def unwrap_failure: () -> E

      def success: () -> result[T, E]

      def failure: () -> result[T, E]

      def map: [U] { (T) -> U } -> result[U, E]

      def map_failure: [F] { (E) -> F } -> result[T, F]
    end
  end
end
