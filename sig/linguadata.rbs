module Linguadata
  VERSION: String

  module DataHelpers
    class ZeroItemData < Data
      def self.new: () -> instance

      def self.[]: () -> instance

      def deconstruct: () -> [ ]

      def deconstruct_keys: (?Array[Symbol]?) -> { }
    end

    class OneItemData[T] < Data
      def deconstruct: () -> [T]

      def deconstruct_keys: (?Array[Symbol]?) -> { Symbol: T }
    end
  end

  module Option
    type option[T] = Some[T] | None

    class Some[T] < DataHelpers::OneItemData[T]
      include _Option[T]

      def self.new: [T] (T) -> Some[T]

      def self.[]: [T] (T) -> Some[T]
    end

    class None < DataHelpers::ZeroItemData
      include _Option[bot]
    end

    interface _Option[T]
      def value: () -> T

      def unwrap: () -> T

      def some?: () -> bool

      def none?: () -> bool

      def map: [U] { (T) -> U } -> option[U]

      def unwrap_or: [U] (U) -> (T | U)

      def unwrap_or_else: [U] { () -> U } -> (T | U)

      def and_then: [U] { (T) -> option[U] } -> option[U]

      def filter: { (T) -> bool } -> option[T]
    end

    def from_nillable: [T] (T? value) -> option[T]
  end

  module Result
    type result[T, E] = Success[T] | Failure[E]

    class Success[T] < DataHelpers::OneItemData[T]
      include _Result[T, bot]

      def self.new: [T] (T) -> Success[T]

      def self.[]: [T] (T) -> Success[T]
    end

    class Failure[E] < DataHelpers::OneItemData[E]
      include _Result[bot, E]

      def self.new: [E] (E) -> Failure[E]

      def self.[]: [E] (E) -> Failure[E]
    end

    interface _Result[T, E]
      def value: () -> T

      def error: () -> E

      def unwrap: () -> T

      def unwrap_failure: () -> E

      def success: () -> Option::option[T]

      def failure: () -> Option::option[E]

      def map: [U] { (T) -> U } -> result[U, E]

      def map_failure: [F] { (E) -> F } -> result[T, F]
    end
  end
end
